------------------------------------------
| Development journal for coqdoc project |
------------------------------------------

31/10/12
                                          /\
                                         / /
                                      __( (__
                                  .-'(    `' )`-.
                                ./    `"""""'    \.
                               /     ___   ___     \
                              /        \\ //        \
                             ;       /\      /\      ;
                            ;       /O_\    /O_\      ;
                            |            /\           |
                            ;            ~~           ;
                             ;     /\.        ./\    ;
                              \   |/`\\/\/\/\//`\|  /
                               \      \/\/\/\/     /
                                `\               /'
                                  `-..___..__..-'

  Commande parse : la version "haut niveau" présente quelques difficultés:
    Le module de pretty print n'offre pas de solution attractive. Sa
    tache principale est de s'interface sur le module Format de caml, et la
    les types qui sont gérés par ce module sont très fortement liés au
    module format (box, break, ...). Pour ce que l'on désire dans le protocole
    Xml, c'est fortement inadapté.
    Ce module Pp s'interface directement avec Vernac_expr. La traduction
    vernac_expr vers pretty print se fait par l'intermédiaire d'une fonction
    qui traduit directement les types de vernac_expr en chaine de caractère.
    L'approche naïve consisterait ) recoder une fonction similaire pour
    faire une traduction vers le xml.

    Ainsi, deux approchent s'offre à nous pour vernac_expr -> xml. Tout
    d'abord une traduction naïve, imposant aux "clients" du protocole xml
    de manipuler directement le type vernacexpr. C'est de mon point de vue une
    mauvaise solution car:
    1) On ne veut pas forcément tout le type vernacexpr (notamment les
      commandes telles que undo, etc ...)
    2) On veut une granularité différente du coté client (contrôle sur
      les preuves uniquement, etc ...), et le type vernacexpr n'est pas du
      tout adapté pour cela.
    Au final, l'approche idéale consisterai à refaire un type entre vernacexpr
    et le xml, ce type étant manipulé également du coté client. Celui devrait
    posséder une structure pensée pour le client, et une granularité importante
    pour offrir un controle riche du coté client ... Cependant, à l'heure
    actuelle, je n'ai qu'une idée floue de ce que l'on désire du coté client,
    et également de la structuration du type.

22/10/12
  Ce qu'il reste à faire:
    - Avoir un front-end generique: pour l'instant, celui ci est directement
      orienté coqdoc. On veut pouvoir gérer coqtex de manière intelligente

    - La "chaîne de compilation" est relativement bien posée. Il reste à la
      raffiner et il faut commencer à définir également les commandes que l'on
      veut rajouter dans le langage des .v. Egalement, il faut réfléchir sur
      l'extensibilité du Cst.doc, et comment rendre cela accessible à
      l'utilisateur
    - De l'autre coté, il faut améliorer la commande parse du protocole xml,
      pour qu'elle mette en forme le code source de coq. Mon idée, plutôt que
      de traiter les types Vernac_expr et constr_expr est de refaire un parser
      qui extraie les informations dont on a besoin à partir des lexemes
      (notamment monter un cst)
    - Coté back-end, les bases sont posées. Il faut commencer également à
      voir ce que l'on veut donner par défaut comme éléments à l'utilisateur,
      et réfléchir sur l'extensibilité de la sortie.
    - L'ajout d'un format de sortie .vdoc est également à faire, cela devrait
      être facile à faire
    - Enfin, cf 17/10/12, il faudrait du code review sur la chaine de
      compilation, surtout au niveau des types.

17/10/12
  - On utilise des variants polymorphes pour le type Cst.doc:
      c'est cool, on est extensible en entrée et en sortie au niveau
      des types (on pourrait imaginer permettre à l'utilisateur d'étendre
      la grammaire d'entrée). Quid de la sécurité ???
  - Pour l'instant, le type ast est moche. C'est un variant bête : soit
    de la doc, soit une requête. Après évaluation, tout les éléments de
    l'ast doivent être de type doc. On voudrait plus de contraintes sur
    le type.
  - la fonction to_output s'occupe de la sortie. Elle prend une fonction
    définie par l'utilisateur, qui sera appliquée sur l'AST. A l'heure
    actuelle, celle ci renvoie du type string option. Si son retour est
    None, on applique la fonction par défaut.
    Cela manque clairement de sureté au niveau des types. Peut-être existe
    t'il une meilleure solution ???

25/09/12
  - Patch les coordonnées de l'AST
  - Le lexer de coqdoc-old est intégré. Il faut finaliser la conversion
    entrée -> AST (pour l'instant, seulement le verbatim)
  - Ajout d'un fichier vdoc.ml qui contient le type Vdoc (début d'ast)

24/09/12
  - Extraction des coordonnées dans l'AST faite

18/09/12:
  - Definir clairement ce que l'on veut obtenir de parser: identifiants,
      mots clefs ?
      (doit permettre de définir un type, et de savoir quels éléments on
      doit extraire de l'AST)


  - Décider à propos de la refonte complète du protocole  (pour suivre
    commande/requêtes)
  - Implémenter un CST dans coq ?
  - Commencer à définir la spécification du langage des .vdoc
